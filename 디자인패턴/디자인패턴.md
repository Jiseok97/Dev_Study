# 디자인 패턴
<img width="920" alt="디자인패턴" src="https://user-images.githubusercontent.com/64394744/136643584-0cbba828-8b21-4a9b-8737-298ef3aa8f0f.png">

## ‣ About **"Design Pattern"** ?
* What is the **Design Pattern** ?
    * 과거의 SW 개발 과정에서 발견된 설계의 노하우를 축척하여 그 방법에 이름을 붙여서 이후에 **재사용**하기 좋은 형태로 **특정 규약**을 만들어서 정리한 것
    * "효율적인 코드를 만들기 위한 방법론"
    </br>
* 디자인 패텅의 종류
    * 생성 패턴
    * 구조 패턴
    * 행위 패턴
</br>    
    
## ‣ About 생성 패턴(Creational Patterns)
> **객체 생성**에 관련된 패턴 </br>
> 객체의 생성과 조합을 **캡슐화**해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 **유연성**을 제공한다.
</br>

### 📖 종류 ▾

* 싱글톤 패턴(Singleton)
    * 클래스의 인스턴스가 **하나임을 보장**하고 접근할 수 있는 **전역적인 접근점**을 제공하는 패턴으로, 디자인 패턴의 가장 많이 알려진 패턴
    
* 추상팩토리 패턴(Abstract Factory)
    * 구체적인 클래스를 지정하지 않고 **관련성이 있거나, 독립적인 객체들을 생성**하기 위한 **인터페이스**를 제공하는 패턴
    
* 빌더 패턴(Builder)
    * 복학 객체의 생성과정과 표현과정을 분리시켜 동일한 **생성과정**에서 다양한 표현을 생성할 수 있는 패턴
    
* 팩토리 메소드 패턴(Factory Method)
    * 객체를 생성하는 인터페이스를 정의하지만, 인스턴스를 만드는 클래스는 **서브클래스**에서 결정하도록 하는 패턴
    * 인스턴스를 만드는 것을 서브클래스에서 하게 됨
    
* 원형 패턴(Prototype)
    * 생성할 객체의 종류를 명시하는 데 **원형이 되는 예시물을 이용**하고 새로운 객체를 이 원형들에 복사함으로써 생성하는 패턴
</br>

## ‣ About 구조 패턴(Structural Patterns)
> 클래스나 객체를 조합해 **더 큰 구조**를 만드는 패턴 </br>
> 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 **단일 인터페이스를 제공**하거나, 서로 다른 객체들을 묶어 **새로운 기능**을 제공하는 패턴
</br>

### 📖 종류 ▾

* 적응자 패턴(Adapter or Wrapper)
    * 클래스의 인터페이스를 사용자가 기대하는 **다른 인터이스로 변환**하는 패턴
    * 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해주는 패턴
    
    * 브릿지 패턴(Bridge)
        * 구현부에 **추상층**을 분리하여 각자 독립적으로 변형할 수 있도록 하는 패턴
    
    * 컴포지트 패턴(Composite)
        * 객체들의 관계를 **트리 구조**로 구성하여 **부분 - 전체** 계층을 표현하는 패턴
        * 사용자가 단일 / 복합객체 모두 동일하게 다루도록 하는 패턴
        
    * 데코레이터 패턴(Decorator)
        * 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴
        * **기능 확장**이 필요할 때 서브클래스 대신 쓸 수 있는 대안이 될 수 있음
        
    * 퍼사드 패턴(Facade)
        * 서브시스템에 있는 인터페이스 집합에 통합된 **하나의 인터페이스**를 제공
        * 서브시스템을 좀 더 쉽게 사용하기 위해 고수준의 인터페이스를 정의함
        
    * 프록시 패턴(Proxy)
        * 어떤 다른 객체로 **접근하는 것을 통제**하기 위해 그 객체의 **매니저** 또는 **자리 채움자**를 제공하는 패턴
</br>

## ‣ About 행위 패턴(Behavioral Patterns)
> 객체나 클래스 사이의 **알고리즘**이나 **책임 분배**에 관련된 패턴 </br>
> 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 그렇게 하면서도 객체 사이의 **결합도를 최소화**하는것에 중점을 두는 방식
</br>

### 📖 종류 ▾
* 옵저버 패턴(Observer)
    * 객체들 사이에 1:N의 의존관계를 정의하여 **어떤 객체의 상태가 변할 때**, 의존 관계에 있는 모든 객체들이 통지받고 **자동으로 갱신**될 수 있게 만드는 패턴
    
* 상태 패턴(State)
    * **객체의 내부 상태**가 변경될 때 **행동을 변경**하도록 허락함
    * 객체는 **자신의 클래스가 변경되는 것**처럼 보이게 됨
    
* 스트레이트지 패턴(Strategy)
    * **동일 계열**의 알고리즘들을 정의하고, 각각 **캡슐화**하여 이들을 **상호교환**이 가능하도록 만드는 것
    * 알고리즘을 사용하는 사용자로부터 독립적으로 알고리즘이 변경될 수 있도록 하는 패턴
    
* 템플릿 패턴(Template)
    * 객체의 연산에서 **알고리즘의 뼈대**만 정의하고, **나머지는 서브클래스**에서 이루어지게 하는 패턴
    * 알고리즘의 구조는 변경하지 않고 알고리즘의 각 단계를 서브클래스에서 **재정의**하게 됨
    
* 비지터 패턴(Visitor)
    * 객체구조를 이루는 원소에 대해 수행할 **연산**을 표현함
    * 방문자는 연산에 적용할 원소의 클래스를 변경하지 않고 **새로운 연산**을 재정의 할 수 있음
    
* 역할 사슬 패턴(Chain of Responsibility)
    * 요청을 처리하는 기회를 **하나 이상의 객체**에 부여하여 요청을 보내는 쪽과 받는 쪽의 결합을 피하는 패턴
    * 요청을 받는 객체를 연쇄적으로 묶고 객체를 처리할 수 있는 때까지 요청을 전달함

* 커맨드 패턴(Command)
    * 요청을 객체로 **캡슐화**하여 서로 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 연산의 취소를 지원하게 만드는 패턴
    
* 인터프리터 패턴(Interpreter)
    * 주어진 언어에 대해서 문법을 위한 표현수단을 정의하고, 해당 언어로 된 문장을 해석하는 **해석기**를 사용하는 패턴
    
* 이터레이터 패턴(Iterator)
    * 내부 표현부를 **노출하지 않고** 어떤 객체 집합의 원소들을 **순차적으로 접근**할 수 있는 방법을 제공하는 패턴
    
* 미디에이터 패턴(Mediator)
    * 한 집합에 속해있는 개체들의 **상호작용을 캡슐화**하는 객체를 정의하는 패턴
    * 중재자는 **객체들이 직접 서로 참조하지 않도록함**으로써 객체들간의 **느슨한 연결**을 촉진시키며 객체들의 상호작용을 독립적으로 다양화 시킬 수 있도록 해줌 
