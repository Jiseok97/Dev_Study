# ‣  커맨드 패턴 ( Command Pattern) 💻
> UML 도식화 ▾
<img width="930" alt="Command-UML" src="https://user-images.githubusercontent.com/64394744/138112372-b5d5242f-b67a-4274-8659-1d3cd113bc13.png">
<hr/>

* **Command**
    * 실행될 기능에 대한 인터페이스를 선언하는 객체
    * Command를 실행하기 위한 하나의 메서드로 이루어진 경우가 많다.
    
* **Concreate Command** 
    * 실제로 실행되는 인터페이스를 구현하는 객체
    * Receiver 객체와 작업 사이 **바인딩**을 정의한다.
    * Receiver에서 해당 작업을 호출하여 실행한다.
    * 직접 작업을 수행하는 것이 아닌 **Recevier에게 전달하기 위한 목적**을 갖고 있다.
    * 코드를 **단순화**하기 위해 클래스를 합칠 수도 있다.

* **Client**
    * Concreate Command 객체를 만들고 Receiver를 설정한다.
    * Receiver의 **인스턴스**를 포함한 작업에 필요한 모든 매개변수를 Command의 **생성자**에 전달하여 작업을 처리한다.

* **Invoker**
    * 기능의 실행을 요청하는 호출자 클래스 객체
    * Invoker 클래스에는 **명령 객체**에 대한 참조를 저장하기 위한 **필드**가 있어야 한다.
    * Client가 생성자를 통해 Invoker 객체를 만들 때 Command 객체를 받게 된다.
    * 요청을 Receiver에게 직접 보내는 것이 아닌 해당 **요청의 시작**을 담당한다.
    
* **Receiver**
    * Concreate Command 객체에서 실행할 메서드를 구현할 때 필요한 클래스 객체
    * Concreate Command 객체의 기능을 실행하기 위해서 사용하는 수신자 클래스 객체
<hr/> </br>

## ‣  About **"Command Pattern"**  📖
* **실행될 기능을 캡슐화**함으로써 주어진 여러 기능을 실행할 수 있는 **재사용성이 높은 클래스**를 설계하는 행위패턴이다.

    * Why **Encapsulation(캡슐화)** ?
    
        * 기능의 실행을 요구하는 **호출자(Invoker)** 클래스와 실제 기능을 실행하는 **수신자(Receiver)** 클래스 사이의 **의존성을 제거**한다.
        
        * 따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용할 수 있도록 해준다.
        
- 이벤트가 발생했을 때 **실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생시키는 클래스를 변경하지 않고 재사용**하고자 할 때 유용하다.

* When used **Command pattern**?
    * 작업을 **캡술화**해서 Receiver에게 보내서 처리하고 싶을 때 사용하면 좋다.
</br>
    
## ‣  Command Pattern 장/단점  ⭐️
* 장점 
    * Single Responsibility (단일 책임 원칙)을 만족한다. Command 객체를 통해 **작업을 수행하는 객체**와 **작업을 호출하는 객체**를 나눌 수 있다.
    
    * Open / Closed Principle (개방 / 폐쇄 원칙)을 만족한다. 클라이언트의 코드를 수정하지 않고도 새로운 Command를 추가할 수 있다.
    
    * 실행 취소, 다시 실행을 구현할 수 있다.
    
    * 작업의 시작을 지연시킬 수 있다.
    
    * 여러 개의 단순한 명령을 조합해서 복잡한 명령을 만들 수 있다.
    
* 단점
    * Receiver, Invoker 사이에 관계를 도입해야 하므로 **코드가 복잡**해질 수 있다.
</br>    

